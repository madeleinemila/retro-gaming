$( ".pages.snake" ).ready( function () {
  const game = new Phaser.Game( 640, 480, Phaser.AUTO, 'snake', { preload: preload, create: create, update:update } );

  // Globals
  let snake;
  let food;
  let cursors;
  let wasd;

  const SNAKE_START_LENGTH = 3;

  // Directional constants
  const UP = 1;
  const DOWN = 2;
  const LEFT = 3;
  const RIGHT = 4;

  // Canvas size
  const CANVAS_WIDTH = 640;
  const CANVAS_HEIGHT = 480;

  // Grid constants
  const BLOCK_SIZE = 16;
  // Grid ranges from 0,0 - 39,29
  const GRID_WIDTH = ( CANVAS_WIDTH / BLOCK_SIZE ) - 1;
  const GRID_HEIGHT = ( CANVAS_HEIGHT / BLOCK_SIZE ) - 1;

  function preload () {
    this.load.image( 'food', "<%= asset_path( 'snake/food.png' ) %>")
    this.load.image( 'body', "<%= asset_path( 'snake/body.png' ) %>")
  }

  function create () {
    game.stage.backgroundColor = '#bfcc00';

    snake = [];
    for ( let i = 0; i < SNAKE_START_LENGTH; i++ ) {
      snake[i] = game.add.sprite( 0 + ( i * BLOCK_SIZE ), 0, 'body' );
    }
    snake.speed = 0;
    snake.grow = false;

    generateFood();

    snake.updateDelay = 0;

    snake.collideWithFood = function ( head, food ) {
      if ( head.x === food.x && head.y === food.y ) {
        food.destroy();
        generateFood();
        snake.grow = true;
      }
    }

    cursors = game.input.keyboard.createCursorKeys();

    wasd = {
      up: game.input.keyboard.addKey( Phaser.Keyboard.W ),
      down: game.input.keyboard.addKey( Phaser.Keyboard.S ),
      left: game.input.keyboard.addKey( Phaser.Keyboard.A ),
      right: game.input.keyboard.addKey( Phaser.Keyboard.D )
    }
  }

  function update () {
    // Snake movement
    if ( cursors.left.isDown && snake.direction !== RIGHT ) {
      // console.log( 'left' );
      snake.newDirection = LEFT;
    }
    if ( cursors.right.isDown && snake.direction !== LEFT ) {
      // console.log( 'right' );
      snake.newDirection = RIGHT;
    }
    if ( cursors.up.isDown && snake.direction !== DOWN ) {
      console.log( 'cursor up' );
      snake.newDirection = UP;
      console.log( 'snake.newDirection:', snake.newDirection );
    }
    if ( cursors.down.isDown && snake.direction !== UP ) {
      // console.log( 'down' );
      snake.newDirection = DOWN;
    }

    if ( wasd.left.isDown && snake.direction !== RIGHT ) {
      snake.newDirection = LEFT;
    }
    if ( wasd.right.isDown && snake.direction !== LEFT ) {
      snake.newDirection = RIGHT;
    }
    if ( wasd.up.isDown && snake.direction !== DOWN ) {
      snake.newDirection = UP;
    }
    if ( wasd.down.isDown && snake.direction !== UP ) {
      snake.newDirection = DOWN;
    }

    snake.updateDelay++;

    if ( snake.updateDelay % 10 === 0 ) {
      const firstSegment = snake[ snake.length - 1 ];
      const lastSegment = snake.shift()
      const oldLastSegmentX = lastSegment.x;
      const oldLastSegmentY = lastSegment.y;

      if ( snake.newDirection ) {
        console.log( 'snake.direction:', snake.direction );
        snake.direction = snake.newDirection;
        console.log( 'snake.direction:', snake.direction );
        snake.newDirection = null;
      }

      // console.log( 'snake.direction:', snake.direction );
      switch ( snake.direction ) {
        case LEFT:
        lastSegment.x = firstSegment.x - BLOCK_SIZE;
        lastSegment.y = firstSegment.y;
        break;
        case RIGHT:
        lastSegment.x = firstSegment.x + BLOCK_SIZE;
        lastSegment.y = firstSegment.y;
        break;
        case UP:
        console.log( 'going up' );
        lastSegment.x = firstSegment.x;
        lastSegment.y = firstSegment.y - BLOCK_SIZE;
        break;
        case DOWN:
        lastSegment.x = firstSegment.x;
        lastSegment.y = firstSegment.y + BLOCK_SIZE;
        break;
      }

      snake.push( lastSegment );

      // Increase snake length
      if ( snake.grow ) {
        snake.unshift( game.add.sprite( oldLastSegmentX, oldLastSegmentY, 'body' ) );
        snake.grow = false;
      }

      snake.collideWithFood( firstSegment, food );
    }
    // End snake movement

  } // End update

  function generateFood() {
    console.log( 'generating food' );
    const x = _.random( CANVAS_WIDTH / BLOCK_SIZE ) * BLOCK_SIZE;
    const y = _.random( CANVAS_HEIGHT / BLOCK_SIZE ) * BLOCK_SIZE;

    console.log( x, y );

    food = game.add.sprite( x, y, 'food' )
  }
} );
