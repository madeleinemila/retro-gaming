$( ".pages.snake" ).ready( function () {
  const game = new Phaser.Game( 640, 480, Phaser.AUTO, 'snake', { preload: preload, create: create, update:update } );

  // Globals
  let snake;
  let food;
  let cursors;
  let wasd;

  const SNAKE_START_LENGTH = 3;

  // Directional constants
  const UP = 1;
  const DOWN = 2;
  const LEFT = 3;
  const RIGHT = 4;

  // Canvas size
  const CANVAS_WIDTH = 640;
  const CANVAS_HEIGHT = 480;

  // Grid constants
  const BLOCK_SIZE = 16;
  // Grid ranges from 0,0 - 39,29
  const GRID_WIDTH = ( CANVAS_WIDTH / BLOCK_SIZE ) - 1;
  const GRID_HEIGHT = ( CANVAS_HEIGHT / BLOCK_SIZE ) - 1;

  function preload () {
    this.load.image( 'food', "<%= asset_path( 'snake/food.png' ) %>")
    this.load.image( 'body', "<%= asset_path( 'snake/body.png' ) %>")
  }

  function create () {
    game.stage.backgroundColor = '#F7DA00';

    snake = [];
    snake[0] = game.add.sprite( ( 8 * BLOCK_SIZE ), ( 8 * BLOCK_SIZE ), 'body' );
    // for ( let i = 0; i < SNAKE_START_LENGTH; i++ ) {
    //   snake[i] = game.add.sprite( ( ( i + 8 ) * BLOCK_SIZE ), ( 8 * BLOCK_SIZE ), 'body' );
    // }
    snake.speed = 0;
    snake.grow = false;
    snake.alive = true;


    snake.updateDelay = 0;

    snake.collideWithFood = function ( head, food ) {
      if ( head.x === food.x && head.y === food.y ) {
        food.destroy();
        generateFood();
        snake.grow = true;
      }
    }

    snake.collideWithSelf = function ( head ) {
      for ( let i = 0; i < snake.length - 1; i++ ) {
        if ( head.x === snake[i].x && head.y === snake[i].y ) {
          snake.alive = false;
          return;
        }
      }
    }

    snake.collideWithWall = function ( head ) {
      if ( head.x >= CANVAS_WIDTH || head.x < 0 || head.y >= CANVAS_HEIGHT || head.y < 0 ) {
        snake.alive = false;
        return;
      }
    }

    generateFood();

    cursors = game.input.keyboard.createCursorKeys();

    wasd = {
      up: game.input.keyboard.addKey( Phaser.Keyboard.W ),
      down: game.input.keyboard.addKey( Phaser.Keyboard.S ),
      left: game.input.keyboard.addKey( Phaser.Keyboard.A ),
      right: game.input.keyboard.addKey( Phaser.Keyboard.D )
    }
  }

  function update () {
    if ( !snake.alive ) {
      return;
    }

    // Snake movement
    if ( cursors.left.isDown && snake.direction !== RIGHT ) {
      snake.newDirection = LEFT;
    }
    if ( cursors.right.isDown && snake.direction !== LEFT ) {
      snake.newDirection = RIGHT;
    }
    if ( cursors.up.isDown && snake.direction !== DOWN ) {
      snake.newDirection = UP;
    }
    if ( cursors.down.isDown && snake.direction !== UP ) {
      snake.newDirection = DOWN;
    }

    if ( wasd.left.isDown && snake.direction !== RIGHT ) {
      snake.newDirection = LEFT;
    }
    if ( wasd.right.isDown && snake.direction !== LEFT ) {
      snake.newDirection = RIGHT;
    }
    if ( wasd.up.isDown && snake.direction !== DOWN ) {
      snake.newDirection = UP;
    }
    if ( wasd.down.isDown && snake.direction !== UP ) {
      snake.newDirection = DOWN;
    }

    snake.updateDelay++;
    if ( snake.updateDelay % ( 10 - snake.speed ) === 0 ) {
      let firstSegment = snake[ snake.length - 1 ];
      const lastSegment = snake.shift();
      const oldLastSegmentX = lastSegment.x;
      const oldLastSegmentY = lastSegment.y;

      if ( snake.newDirection ) {
        snake.direction = snake.newDirection;
        snake.newDirection = null;
      }

      switch ( snake.direction ) {
        case LEFT:
        lastSegment.x = firstSegment.x - BLOCK_SIZE;
        lastSegment.y = firstSegment.y;
        break;
        case RIGHT:
        lastSegment.x = firstSegment.x + BLOCK_SIZE;
        lastSegment.y = firstSegment.y;
        break;
        case UP:
        // console.log( 'going up' );
        lastSegment.x = firstSegment.x;
        lastSegment.y = firstSegment.y - BLOCK_SIZE;
        break;
        case DOWN:
        lastSegment.x = firstSegment.x;
        lastSegment.y = firstSegment.y + BLOCK_SIZE;
        break;
      }

      snake.push( lastSegment );
      firstSegment = lastSegment;

      // Increase snake length
      if ( snake.grow ) {
        snake.unshift( game.add.sprite( oldLastSegmentX, oldLastSegmentY, 'body' ) );
        snake.grow = false;

        if ( snake.length % 3 === 0 ) {
          snake.speed++
        }
      }

      snake.collideWithFood( firstSegment, food );

      snake.collideWithSelf( firstSegment );

      snake.collideWithWall( firstSegment );

    }
    // End snake movement

  } // End update

  function generateFood() {
    const x = _.random( GRID_WIDTH ) * BLOCK_SIZE;
    const y = _.random( GRID_HEIGHT ) * BLOCK_SIZE;

    food = game.add.sprite( x, y, 'food' )
  }
} );
