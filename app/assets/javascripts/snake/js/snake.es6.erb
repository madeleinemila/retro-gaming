$( ".pages.snake" ).ready( function () {
  const game = new Phaser.Game( 640, 480, Phaser.AUTO, 'snake', { preload: preload, create: create, update:update } );

  // Globals

  const highScore = <%= Score.first.snaak %>

  let snake;
  let snake2;
  let food;
  let cursors;
  let wasd;

  // Directional constants
  const UP = 1;
  const DOWN = 2;
  const LEFT = 3;
  const RIGHT = 4;

  // Canvas size
  const CANVAS_WIDTH = 640;
  const CANVAS_HEIGHT = 480;

  // Grid constants
  const BLOCK_SIZE = 16;
  // Grid ranges from 0,0 - 39,29
  const GRID_WIDTH = ( CANVAS_WIDTH / BLOCK_SIZE ) - 1;
  const GRID_HEIGHT = ( CANVAS_HEIGHT / BLOCK_SIZE ) - 1;

  function preload () {
    this.load.image( 'food', "<%= asset_path( 'snake/food.png' ) %>")
    this.load.image( 'body', "<%= asset_path( 'snake/body.png' ) %>")
  }

  function create () {
    game.stage.backgroundColor = '#F7DA00';

    snake = [];
    snake[0] = game.add.sprite( ( 8 * BLOCK_SIZE ), ( 8 * BLOCK_SIZE ), 'body' );
    snake.speed = 0;
    snake.grow = false;
    snake.alive = true;

    snake2 = [];
    snake2[0] = game.add.sprite( ( GRID_WIDTH - 8 ) * BLOCK_SIZE , ( GRID_HEIGHT - 8 ) * BLOCK_SIZE , 'body' );
    snake2.speed = 0;
    snake2.grow = false;
    snake2.alive = true;

    snake.updateDelay = 0;

    generateFood();

    cursors = game.input.keyboard.createCursorKeys();

    wasd = {
      up: game.input.keyboard.addKey( Phaser.Keyboard.W ),
      down: game.input.keyboard.addKey( Phaser.Keyboard.S ),
      left: game.input.keyboard.addKey( Phaser.Keyboard.A ),
      right: game.input.keyboard.addKey( Phaser.Keyboard.D )
    }
  }

  function update () {
    snake.updateDelay++;

    if ( snake.alive ) {
      // Snake movement
      if ( ( cursors.left.isDown || hardwareL ) && snake.direction !== RIGHT ) {
        snake.newDirection = LEFT;
      }
      if ( ( cursors.right.isDown || hardwareR ) && snake.direction !== LEFT ) {
        snake.newDirection = RIGHT;
      }
      if ( ( cursors.up.isDown || hardwareU ) && snake.direction !== DOWN ) {
        snake.newDirection = UP;
      }
      if ( ( cursors.down.isDown || hardwareD ) && snake.direction !== UP ) {
        snake.newDirection = DOWN;
      }

      if ( snake.updateDelay % ( 10 - snake.speed ) === 0 ) {
        let firstSegment = snake[ snake.length - 1 ];
        const lastSegment = snake.shift();
        const oldLastSegmentX = lastSegment.x;
        const oldLastSegmentY = lastSegment.y;

        if ( snake.newDirection ) {
          snake.direction = snake.newDirection;
          snake.newDirection = null;
        }

        switch ( snake.direction ) {
          case LEFT:
          lastSegment.x = firstSegment.x - BLOCK_SIZE;
          lastSegment.y = firstSegment.y;
          break;
          case RIGHT:
          lastSegment.x = firstSegment.x + BLOCK_SIZE;
          lastSegment.y = firstSegment.y;
          break;
          case UP:
          // console.log( 'going up' );
          lastSegment.x = firstSegment.x;
          lastSegment.y = firstSegment.y - BLOCK_SIZE;
          break;
          case DOWN:
          lastSegment.x = firstSegment.x;
          lastSegment.y = firstSegment.y + BLOCK_SIZE;
          break;
        }

        snake.push( lastSegment );
        firstSegment = lastSegment;

        // Increase snake length
        if ( snake.grow ) {
          snake.unshift( game.add.sprite( oldLastSegmentX, oldLastSegmentY, 'body' ) );
          snake.grow = false;
          if ( snake.length > highScore ) {
             $.post(`https://gehms.herokuapp.com/snake/${ snake.length }`).done((res) => {
             // $.post(`http://localhost:3000/snake/${ snake.length }`).done((res) => {
               $('#snake-score').text( snake.length );
             });
          }

          if ( snake.length % 3 === 0 ) {
            snake.speed++
          }
        }

        collideWithFood( snake, firstSegment, food );

        collideWithSelf( snake, firstSegment );

        collideWithWall( snake, firstSegment );

        collideWithEnemy( snake, firstSegment, snake2 );

      }
      // End snake movement
    }
    if ( snake2.alive ) {
      // Snake2 movement
      if ( ( wasd.left.isDown || hardwareL2 ) && snake2.direction !== RIGHT ) {
        snake2.newDirection = LEFT;
      }
      if ( ( wasd.right.isDown || hardwareR2 ) && snake2.direction !== LEFT ) {
        snake2.newDirection = RIGHT;
      }
      if ( ( wasd.up.isDown || hardwareU2 ) && snake2.direction !== DOWN ) {
        snake2.newDirection = UP;
      }
      if ( ( wasd.down.isDown || hardwareD2 ) && snake2.direction !== UP ) {
        snake2.newDirection = DOWN;
      }
      if ( !snake.alive ) {

      }
      if ( snake.updateDelay % ( 10 - snake2.speed ) === 0 ) {
        let firstSegment2 = snake2[ snake2.length - 1 ];
        const lastSegment2 = snake2.shift();
        const oldLastSegmentX2 = lastSegment2.x;
        const oldLastSegmentY2 = lastSegment2.y;

        if ( snake2.newDirection ) {
          snake2.direction = snake2.newDirection;
          snake2.newDirection = null;
        }

        switch ( snake2.direction ) {
          case LEFT:
          lastSegment2.x = firstSegment2.x - BLOCK_SIZE;
          lastSegment2.y = firstSegment2.y;
          break;
          case RIGHT:
          lastSegment2.x = firstSegment2.x + BLOCK_SIZE;
          lastSegment2.y = firstSegment2.y;
          break;
          case UP:
          // console.log( 'going up' );
          lastSegment2.x = firstSegment2.x;
          lastSegment2.y = firstSegment2.y - BLOCK_SIZE;
          break;
          case DOWN:
          lastSegment2.x = firstSegment2.x;
          lastSegment2.y = firstSegment2.y + BLOCK_SIZE;
          break;
        }

        snake2.push( lastSegment2 );
        firstSegment2 = lastSegment2;

        // Increase snake2 length
        if ( snake2.grow ) {
          snake2.unshift( game.add.sprite( oldLastSegmentX2, oldLastSegmentY2, 'body' ) );
          snake2.grow = false;
          if ( snake2.length > highScore ) {
             // $.post(`http://localhost:3000/snake/${ snake2.length }`).done((res) => {
             $.post(`https://gehms.herokuapp.com/snake/${ snake2.length }`).done((res) => {
                $('#snake-score').text( snake2.length );
             });
          }

          if ( snake2.length % 3 === 0 ) {
            snake2.speed++
          }
        }

        collideWithFood( snake2, firstSegment2, food );

        collideWithSelf( snake2, firstSegment2 );

        collideWithWall( snake2, firstSegment2 );

        collideWithEnemy( snake2, firstSegment2, snake );

      }
      // End snake2 movement
    }
  } // End update

  function generateFood() {
    const x = _.random( GRID_WIDTH ) * BLOCK_SIZE;
    const y = _.random( GRID_HEIGHT ) * BLOCK_SIZE;

    food = game.add.sprite( x, y, 'food' )
  }

  function collideWithFood ( player, head, food ) {
    if ( head.x === food.x && head.y === food.y ) {
      food.destroy();
      generateFood();
      player.grow = true;
    }
  }

  function collideWithSelf ( player, head ) {
    for ( let i = 0; i < player.length - 1; i++ ) {
      if ( head.x === player[i].x && head.y === player[i].y ) {
        player.alive = false;
        return;
      }
    }
  }

  function collideWithWall ( player, head ) {
    if ( head.x >= CANVAS_WIDTH || head.x < 0 || head.y >= CANVAS_HEIGHT || head.y < 0 ) {
      player.alive = false;
      return;
    }
  }

  function collideWithEnemy ( player, head, enemy ) {
    for ( let i = 0; i < enemy.length; i++ ) {
      if ( head.x === enemy[i].x && head.y === enemy[i].y ) {
        player.alive = false;
        return;
      }
    }
  }

} );
